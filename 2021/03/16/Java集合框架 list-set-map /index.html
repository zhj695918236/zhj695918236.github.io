<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java集合框架史上最详解（list set 以及map） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一、集合框架总体架构1.1 集合框架在被设计时需满足的目标①该框架必须是高性能的。基本集合（动态数组、链表、数、哈希表）的实现也必须是高效的； ②该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性； ③对一个集合的扩展和适应必须是简单的。 在了解并熟悉Java集合框架的时候，先了解其在被设计时需满足的目标是必须的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java集合框架史上最详解（list set 以及map）">
<meta property="og:url" content="http://example.com/2021/03/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20list-set-map%20/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="一、集合框架总体架构1.1 集合框架在被设计时需满足的目标①该框架必须是高性能的。基本集合（动态数组、链表、数、哈希表）的实现也必须是高效的； ②该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性； ③对一个集合的扩展和适应必须是简单的。 在了解并熟悉Java集合框架的时候，先了解其在被设计时需满足的目标是必须的。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1glm7pmvdfaj30jr0hjq38.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1glm5v4jumgj30hv0gzglq.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1glm64r1vlpj30la09vmx8.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1glm65ksrkqj30j906rglk.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhxwpf4gj31060h2ai9.jpg">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhzgf0a7j30uq0myk0q.jpg">
<meta property="article:published_time" content="2021-03-16T05:28:59.892Z">
<meta property="article:modified_time" content="2021-03-16T05:28:59.893Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="集合框架 list set map">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/0081Kckwly1glm7pmvdfaj30jr0hjq38.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java集合框架 list-set-map " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20list-set-map%20/" class="article-date">
  <time class="dt-published" datetime="2021-03-16T05:28:59.892Z" itemprop="datePublished">2021-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java集合框架史上最详解（list set 以及map）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、集合框架总体架构"><a href="#一、集合框架总体架构" class="headerlink" title="一、集合框架总体架构"></a>一、集合框架总体架构</h2><h3 id="1-1-集合框架在被设计时需满足的目标"><a href="#1-1-集合框架在被设计时需满足的目标" class="headerlink" title="1.1 集合框架在被设计时需满足的目标"></a>1.1 集合框架在被设计时需满足的目标</h3><p>①该框架必须是高性能的。基本集合（动态数组、链表、数、哈希表）的实现也必须是高效的；</p>
<p>②该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性；</p>
<p>③对一个集合的扩展和适应必须是简单的。</p>
<p>在了解并熟悉Java集合框架的时候，先了解其在被设计时需满足的目标是必须的。</p>
<span id="more"></span>

<h3 id="1-2-所有的集合框架需要包含的内容"><a href="#1-2-所有的集合框架需要包含的内容" class="headerlink" title="1.2 所有的集合框架需要包含的内容"></a>1.2 所有的集合框架需要包含的内容</h3><p><strong>①接口</strong>：是代表集合抽象的数据类型。例如<strong>Collection、List、Set、Map</strong>等。之所以定义多个接口，是为了以不同的方式操作集合对象；</p>
<p><strong>②实现（类）</strong>：是集合接口的具体体现。从本质上讲，它们是可重复的数据结构。例如<strong>ArrayList、LinkedList、HashSet以及HashMap</strong>；</p>
<p><strong>③算法</strong>：是实现集合接口的对象里的方法执行的一些有用的计算，例如：<strong>搜索和排序</strong>。这些算法被称为<strong>多态</strong>，那是因为相同的方法可以在相似的接口上有着不同的实现。</p>
<p><strong>集合框架体系如图所示：</strong></p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwly1glm7pmvdfaj30jr0hjq38.jpg" style="zoom:80%;" />

<h3 id="1-3-Java集合框架图"><a href="#1-3-Java集合框架图" class="headerlink" title="1.3 Java集合框架图"></a>1.3 Java集合框架图</h3><p>先来看一张Java集合框架图：</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glm5v4jumgj30hv0gzglq.jpg" style="zoom:90%;" />

<p>上面这张图虽然详细讲述了Java集合框架，但是乍一看感觉太复杂了，那不妨来看一下下面的这张图，更能一眼就能清晰地明白Java集合框架了。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glm64r1vlpj30la09vmx8.jpg" style="zoom:80%;" />

<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glm65ksrkqj30j906rglk.jpg" style="zoom:88%;" />

<p>从上面的集合框架图可以看出，Java集合框架主要包括两种类型的容器，一种是<strong>集合 （Collection）</strong>，存放一个元素集合，另一种是<strong>图（Map）</strong>，存储键–值对映射。Collection接口又有3种子类型，分别为<strong>List</strong>，<strong>Set</strong>以及<strong>Queue</strong>，再下面是一些抽象类，最后是具体实现类，常用的有<strong>ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等</strong>。</p>
<h3 id="1-4-常用的集合在系统中的区别"><a href="#1-4-常用的集合在系统中的区别" class="headerlink" title="1.4 常用的集合在系统中的区别"></a>1.4 常用的集合在系统中的区别</h3><p><strong>常用的集合在系统中定义了四大接口，这四类的区别是：</strong></p>
<p><strong>①Java.util.Set</strong> 接口及其子类，Set提供的是一个无序的集合，集合中的元素是不可以重复的，访问集合中的元素只能根据元素本身来访问（这也是集合里元素不允许重复的原因）；</p>
<p><strong>②Java.util.List</strong> 接口及其子类，List提供的是一个有序的集合，集合中的元素是可以重复的，访问集合中的元素可以根据元素的索引来访问；</p>
<p><strong>③Java.util.Queue</strong>接口及其子类，提供了基于队列的集合体系；</p>
<p><strong>④Java.util.Map</strong> 接口及其子类，Map提供了一个映射（对应）关系的集合数据结构，访问时只能根据每项元素的key来访问其value；</p>
<p><strong>每一种集合，都可以理解为是用来在内存中存放一组对象的某种”容器”—就像数组，就像我们自己定义的对列。</strong></p>
<h2 id="二、主要分析一下Set、List以及Map三个接口以及实现它们类的方法"><a href="#二、主要分析一下Set、List以及Map三个接口以及实现它们类的方法" class="headerlink" title="二、主要分析一下Set、List以及Map三个接口以及实现它们类的方法"></a>二、主要分析一下Set、List以及Map三个接口以及实现它们类的方法</h2><h3 id="2-1-Set接口及其实现类方法"><a href="#2-1-Set接口及其实现类方法" class="headerlink" title="2.1 Set接口及其实现类方法"></a>2.1 Set接口及其实现类方法</h3><h4 id="2-1-1-Set接口"><a href="#2-1-1-Set接口" class="headerlink" title="2.1.1 Set接口"></a>2.1.1 Set接口</h4><p><strong>Set接口是一种不包括重复元素的Collection，是继承了Collection接口的子接口。</strong> 它维持它自己内部排序，所以对其进行随机访问没有任何意义。与List一样，它同样允许null的存在但仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素必须不同，同时也需要注意任何可变对象。它是一种最简单的集合，只是简单地将对象加入集合中，就好比往口袋里放东西，<strong>但是这里需要注意一下：虽然Set中元素没有顺序，但是元素在Set中的位置是由该元素的HashCode决定的，其具体的位置是固定的</strong>。它有三个具体的实现类，分别为<strong>散列集HashSet、链式散列集LinkedHashSet以及树形集TreeSet。</strong></p>
<p><strong>1）HashSet</strong></p>
<p>​     HashSet 是一个没有重复元素的集合。它是由HashMap实现的，**不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)**，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。</p>
<p><em><strong>HashSet使用和理解中容易出现的误区:</strong></em></p>
<h4 id="a-HashSet中存放null值"><a href="#a-HashSet中存放null值" class="headerlink" title="a.HashSet中存放null值"></a>a.HashSet中存放null值</h4><p>  HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。</p>
<h4 id="b-HashSet中存储元素的位置是固定的"><a href="#b-HashSet中存储元素的位置是固定的" class="headerlink" title="b.HashSet中存储元素的位置是固定的"></a>b.HashSet中存储元素的位置是固定的</h4><p>  HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。</p>
<p>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p>
<h4 id="c-必须小心操作可变对象（Mutable-Object）"><a href="#c-必须小心操作可变对象（Mutable-Object）" class="headerlink" title="c.必须小心操作可变对象（Mutable Object）"></a>c.必须小心操作可变对象（Mutable Object）</h4><p>如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题</p>
<p><strong>2）LinkedHashSet</strong></p>
<p> LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p>
<p><strong>3）TreeSet</strong></p>
<p>   TreeSet是一个<strong>有序集合</strong>，其底层是<strong>基于TreeMap实现的</strong> ， <strong>非线程安全</strong>。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，<strong>自然排序和定制排序</strong>，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</p>
<p><strong>注意：</strong> TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p>
<h4 id="2-1-2-Set接口的用法"><a href="#2-1-2-Set接口的用法" class="headerlink" title="2.1.2 Set接口的用法"></a>2.1.2 Set接口的用法</h4><p>Set是一个接口定义，所以我们只能使用它的实现子类。Set接口常用的子类有<strong>散列集HashSet、链式散列集LinkedHashSet以及树形集TreeSet。</strong>使用起来也非常的简单，请看以下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yf1213.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetTest</span></span>&#123;</span><br><span class="line">    <span class="comment">//程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SetTest test = <span class="keyword">new</span> SetTest();</span><br><span class="line">        Collection sSet = test.getUserSet(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;集合中共有元素：&quot;</span> + sSet.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Set中的所有元素取出来打印</span></span><br><span class="line">        <span class="comment">//又因为Set中的元素是无序的，所以不能通过索引取得，故使用Set的迭代器</span></span><br><span class="line">        Iterator&lt;Student&gt; it = sSet.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            Student st = it.next();</span><br><span class="line">            st.showInfo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 取得指定数量UserInfo对象</span></span><br><span class="line"><span class="comment">    * @param UserCount：要创建的个数</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">getUserSet</span><span class="params">(<span class="keyword">int</span> userCount)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合对象</span></span><br><span class="line">        Set sSet = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;userCount; i++)&#123;</span><br><span class="line">            Student ui = <span class="keyword">new</span> Student(<span class="string">&quot;用户_&quot;</span>+((<span class="keyword">char</span>)(<span class="number">65</span>+i)), i+<span class="number">1</span>);</span><br><span class="line">            sSet.add(ui);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 上述代码中 ui.setName(“用户_”+((char)(65+i)));这句， char 型强制转型，得到一个 int 值对应 ASCLL 码的字符，所以我们看到输出的是 A、 B、 C；这是因为这三个字符对应的 ASCLL 码值是 65,66,67。</p>
<p>Student类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yf1213.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> scroe;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建学生对象，传入姓名和学分值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> scroe)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.scroe = scroe;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输出学生的基本信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;学分：&quot;</span>+scroe);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出的结果：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">集合中共有元素：3</span><br><span class="line">姓名：用户_A学分：1</span><br><span class="line">姓名：用户_C学分：3</span><br><span class="line">姓名：用户_B学分：2</span><br></pre></td></tr></table></figure>

<p>从上述的代码以及输出的结果，可以知道，Set的特点是无序的，所以要取出其中的对象，必须通过Set对象，得到Iterator来遍历这个Set。</p>
<p>同样也能够去看到，我们在集合中放入的对象是有次序的，但在打印时，却不是我们所放入进去的次序，这就能够去说明集合中的对象是无序的，至于它的真实顺序，只有在打印的时候才能得知，在未打印前，并不能真正得到它顺序的。</p>
<h3 id="2-2-List接口以及实现类方法"><a href="#2-2-List接口以及实现类方法" class="headerlink" title="2.2 List接口以及实现类方法"></a>2.2 List接口以及实现类方法</h3><h4 id="2-2-1-List接口"><a href="#2-2-1-List接口" class="headerlink" title="2.2.1 List接口"></a>2.2.1 List接口</h4><p><strong>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。</strong></p>
<p><strong>List接口继承于Collection接口</strong>，它可以定义一个<strong>允许重复的有序集合</strong>。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p>
<p><strong>List接口为Collection直接接口</strong>。List所代表的是<strong>有序的Collection</strong>，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：<strong>ArrayList、LinkedList、Vector、Stack。</strong></p>
<h4 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1)ArrayList"></a>1)ArrayList</h4><p>​      <strong>ArrayList</strong>是一个<strong>动态数组</strong>，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。<strong>所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</strong></p>
<p>​      size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p>
<p>​     <strong>ArrayList擅长于随机访问。同时ArrayList是非同步的。</strong></p>
<h4 id="2-LinkedList"><a href="#2-LinkedList" class="headerlink" title="2)LinkedList"></a>2)LinkedList</h4><p>​      同样实现List接口的LinkedList与ArrayList不同，<strong>ArrayList是一个动态数组，而LinkedList是一个双向链表</strong>。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p>
<p>​      由于实现的方式不同，<strong>LinkedList不能随机访问</strong>，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。<strong>这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</strong></p>
<p>​      与ArrayList一样，<strong>LinkedList也是非同步的</strong>。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(…));</p>
<h4 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3)Vector"></a>3)Vector</h4><p>​      与ArrayList相似，但是<strong>Vector是同步的</strong>。所以说<strong>Vector是线程安全的动态数组</strong>。它的操作与ArrayList几乎一样。</p>
<h4 id="4-Stack"><a href="#4-Stack" class="headerlink" title="4)Stack"></a>4)Stack</h4><p>​     <strong>Stack继承自Vector</strong>，实现一个<strong>后进先出的堆栈</strong>。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的<strong>push</strong>和<strong>pop</strong> 方法，还有<strong>peek</strong>方法得到栈顶的元素，<strong>empty</strong>方法测试堆栈是否为空，<strong>search</strong>方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhxwpf4gj31060h2ai9.jpg" style="zoom:60%;" />



<h4 id="2-2-2-List接口的用法"><a href="#2-2-2-List接口的用法" class="headerlink" title="2.2.2 List接口的用法"></a>2.2.2 List接口的用法</h4><p>相对于无序的Set接口，List接口提供多个实现的子类，提供有序的访问集合中的方法，换言之，就是可以根据List中对象放入时的次序来查找对象。List常用的实现类是Vector和ArrayList。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yf1213.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ListTest st = <span class="keyword">new</span> ListTest();</span><br><span class="line">		List&lt;Student&gt; list = st.getUserList(<span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;List中共有元素：&quot;</span>+list.size());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//取出list中某个位置的元素：</span></span><br><span class="line">	    Student sd = list.get(<span class="number">3</span>);</span><br><span class="line">	    sd.showInfo();</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">//输出列表中所有Student对象信息：</span></span><br><span class="line">	    st.printList(list);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 打印出List中对象的内容</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;Student&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">			Student us = list.get(i);</span><br><span class="line">			us.showInfo();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 取出特定数量Student对象的一个List集合</span></span><br><span class="line"><span class="comment">	 * userCount：要创建的用户个数</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">getUserList</span><span class="params">(<span class="keyword">int</span> userCount)</span></span>&#123;</span><br><span class="line">		List userList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;userCount; i++) &#123;</span><br><span class="line">			Student ui = <span class="keyword">new</span> Student(<span class="string">&quot;用户_&quot;</span>+((<span class="keyword">char</span>)(<span class="number">65</span>+i)), i+<span class="number">1</span>);</span><br><span class="line">			userList.add(ui);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> userList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面所用的Student类跟之前的是一样的，之后的也一样，这里就赘述了！！！</p>
<p><strong>输出的结果为：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List中共有元素：5</span><br><span class="line">姓名：用户_D学分：4</span><br><span class="line">姓名：用户_A学分：1</span><br><span class="line">姓名：用户_B学分：2</span><br><span class="line">姓名：用户_C学分：3</span><br><span class="line">姓名：用户_D学分：4</span><br><span class="line">姓名：用户_E学分：5</span><br></pre></td></tr></table></figure>

<p>从输出的结果可以看出，List接口一个有序的集合，可以通过其索引（即元素在List中的位置，类似于数组的下标）来访问List中的元素的。</p>
<h3 id="2-3-Map接口与其使用方法"><a href="#2-3-Map接口与其使用方法" class="headerlink" title="2.3 Map接口与其使用方法"></a>2.3 Map接口与其使用方法</h3><h4 id="2-3-1Map接口"><a href="#2-3-1Map接口" class="headerlink" title="2.3.1Map接口"></a>2.3.1Map接口</h4><p>  Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。就好比我们再现实生活中，经常也会看到类似这样的集合，比如IP地址与主机名，身份证号码与个人等等这样一一对应关系的例子，这也就叫做<strong>映射</strong>。在Java中，专门提供了这样的集合用来存放这种对象关系的对象，即为<strong>java.util.Map接口</strong>。常常Map接口的实现类主要有：<strong>HashMap、LinkedHashMap以及TreeMap的</strong>。</p>
<h4 id="①HashMap"><a href="#①HashMap" class="headerlink" title="①HashMap"></a>①HashMap</h4><p>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用<strong>散列链表</strong>的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</p>
<h4 id="②LinkedHashMap"><a href="#②LinkedHashMap" class="headerlink" title="②LinkedHashMap"></a>②LinkedHashMap</h4><p> <strong>LinkedHashMap</strong>是<strong>HashMap</strong>的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用<strong>LinkedHashMap</strong>。<br>     <strong>LinkedHashMap</strong>是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。<br>     <strong>LinkedHashMap</strong>实现与<strong>HashMap</strong>的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。<br>     <strong>根据链表中元素的顺序可以分为：</strong> 按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。<br>     <strong>注意：</strong> 此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。<br>     由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p>
<h4 id="③TreeMap"><a href="#③TreeMap" class="headerlink" title="③TreeMap"></a>③TreeMap</h4><p><strong>TreeMap</strong> 是一个有序的<strong>key-value集合</strong>，<strong>非同步，基于红黑树（Red-Black tree）实现</strong>，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是<strong>自然排序</strong>，一种是<strong>定制排序</strong>，<strong>具体取决于使用的构造方法</strong>。</p>
<p><strong>自然排序：</strong> TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p>
<p><strong>定制排序：</strong> 定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p>
<p><strong>TreeMap判断两个元素相等的标准：</strong> 两个key通过compareTo()方法返回0，则认为这两个key相等。</p>
<p>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则<strong>必须重写自定义类中的equals()方法</strong>，<strong>TreeMap中判断相等的标准是</strong>：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。</p>
<img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glmhzgf0a7j30uq0myk0q.jpg" style="zoom:55%;" />

<h4 id="2-3-2-Map接口的用法"><a href="#2-3-2-Map接口的用法" class="headerlink" title="2.3.2 Map接口的用法"></a>2.3.2 Map接口的用法</h4><p>在Map中存放的是两种对象，一种称为key（键），另一种成为value（值），它们在Map中是一一对应的关系，这样一对对象又称为Map中的一个Entry（项）；Map中的key是不能够重复的，但是值是可以重复的。下面是实现Map接口的实现类方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yf1213.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MapTest mt = <span class="keyword">new</span> MapTest();</span><br><span class="line">		Map&lt;String, Student&gt; map = mt.createUserTable();</span><br><span class="line">		<span class="comment">//打印Map中所有的信息：</span></span><br><span class="line">		mt.printMap(map);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据已知的key取出map中对应的一个value：</span></span><br><span class="line">		String key = <span class="string">&quot;&quot;</span>+<span class="number">2</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;取出的key为&quot;</span>+key+<span class="string">&quot;对象的信息是：&quot;</span>);</span><br><span class="line">		Student st = map.get(key);</span><br><span class="line">		st.showInfo();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 创建用户与名字关系的Map对象</span></span><br><span class="line"><span class="comment">	 * 返回：用户名字与用户对象关联的Map对象</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Student&gt; <span class="title">createUserTable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Map userMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; i++) &#123;</span><br><span class="line">			Student us = <span class="keyword">new</span> Student(<span class="string">&quot;我是第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;个&quot;</span>, i);</span><br><span class="line">			userMap.put(<span class="string">&quot;&quot;</span>+i, us);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> userMap;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 遍历Map</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMap</span><span class="params">(Map&lt;String, Student&gt; um)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//得到Map中所有的key的集合</span></span><br><span class="line">		Set&lt;String&gt; set = um.keySet();</span><br><span class="line">		Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//迭代key</span></span><br><span class="line">		<span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			String key = it.next();</span><br><span class="line">			<span class="comment">//取出key对应的value</span></span><br><span class="line">			Student uf = um.get(key);</span><br><span class="line">			uf.showInfo();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出的结果：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">姓名：我是第1个学分：0</span><br><span class="line">姓名：我是第2个学分：1</span><br><span class="line">姓名：我是第3个学分：2</span><br><span class="line">姓名：我是第4个学分：3</span><br><span class="line">姓名：我是第5个学分：4</span><br><span class="line">姓名：我是第6个学分：5</span><br><span class="line">取出的key为2对象的信息是：</span><br><span class="line">姓名：我是第3个学分：2</span><br></pre></td></tr></table></figure>

<p>从输出的结果看，我们可以通过key的值来找到value的值，它们是一一对应的关系。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20list-set-map%20/" data-id="ckmbkxdvw0011edez73bmfu2z" data-title="Java集合框架史上最详解（list set 以及map）" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list-set-map/" rel="tag">集合框架 list set map</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/16/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          选择排序算法（基于Java实现）
        
      </div>
    </a>
  
  
    <a href="/2021/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">一文教会你什么线程安全以及如何实现线程安全</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%8D%E6%98%A0%E5%B0%84-%E6%8E%92%E5%BA%8F-%E6%8E%92%E9%87%8D/" rel="tag">位映射 排序 排重</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">冒泡排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">希尔排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/" rel="tag">归并算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">快速排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95/" rel="tag">插入算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" rel="tag">数组 循环队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84-%E9%98%9F%E5%88%97/" rel="tag">数组 队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84-%E9%A1%BA%E5%BA%8F%E6%A0%88/" rel="tag">数组 顺序栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="tag">桶排序算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-synchronized-volatile-Lock/" rel="tag">线程安全 Java并发 Java内存模型 synchronized volatile Lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" rel="tag">选择算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8-%E9%98%9F%E5%88%97/" rel="tag">链表 队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list-set-map/" rel="tag">集合框架 list set map</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E4%BD%8D%E6%98%A0%E5%B0%84-%E6%8E%92%E5%BA%8F-%E6%8E%92%E9%87%8D/" style="font-size: 10px;">位映射 排序 排重</a> <a href="/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">冒泡排序算法</a> <a href="/tags/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">希尔排序算法</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95/" style="font-size: 10px;">归并算法</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">快速排序算法</a> <a href="/tags/%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95/" style="font-size: 10px;">插入算法</a> <a href="/tags/%E6%95%B0%E7%BB%84-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" style="font-size: 10px;">数组 循环队列</a> <a href="/tags/%E6%95%B0%E7%BB%84-%E9%98%9F%E5%88%97/" style="font-size: 10px;">数组 队列</a> <a href="/tags/%E6%95%B0%E7%BB%84-%E9%A1%BA%E5%BA%8F%E6%A0%88/" style="font-size: 10px;">数组 顺序栈</a> <a href="/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" style="font-size: 10px;">桶排序算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-Java%E5%B9%B6%E5%8F%91-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-synchronized-volatile-Lock/" style="font-size: 10px;">线程安全 Java并发 Java内存模型 synchronized volatile Lock</a> <a href="/tags/%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95/" style="font-size: 10px;">选择算法</a> <a href="/tags/%E9%93%BE%E8%A1%A8-%E9%98%9F%E5%88%97/" style="font-size: 10px;">链表 队列</a> <a href="/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6-list-set-map/" style="font-size: 10px;">集合框架 list set map</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/16/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
          </li>
        
          <li>
            <a href="/2021/03/16/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">选择排序算法（基于Java实现）</a>
          </li>
        
          <li>
            <a href="/2021/03/16/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%20list-set-map%20/">Java集合框架史上最详解（list set 以及map）</a>
          </li>
        
          <li>
            <a href="/2021/03/16/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/">一文教会你什么线程安全以及如何实现线程安全</a>
          </li>
        
          <li>
            <a href="/2021/03/16/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">希尔排序算法（基于Java实现）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>